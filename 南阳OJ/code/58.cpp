/*
描述 
这有一个迷宫，有0~8行和0~8列：

 {1,1,1,1,1,1,1,1,1},
 {1,0,0,1,0,0,1,0,1},
 {1,0,0,1,1,0,0,0,1},
 {1,0,1,0,1,1,0,1,1},
 {1,0,0,0,0,1,0,0,1},
 {1,1,0,1,0,1,0,0,1},
 {1,1,0,1,0,1,0,0,1},
 {1,1,0,1,0,0,0,0,1},
 {1,1,1,1,1,1,1,1,1}

0表示道路，1表示墙。

现在输入一个道路的坐标作为起点，再如输入一个道路的坐标作为终点，问最少走几步才能从起点到达终点？

（注：一步是指从一坐标点走到其上下左右相邻坐标点，如：从（3，1）到（4,1）。）

输入 
第一行输入一个整数n（0<n<=100），表示有n组测试数据;
随后n行,每行有四个整数a,b,c,d（0<=a,b,c,d<=8）分别表示起点的行、列，终点的行、列。 
输出 
输出最少走几步。 
样例输入 
2
3 1  5 7
3 1  6 7
样例输出 
12
11
*/
/*
bfs
*/
#include<stdio.h>
#include<queue>
using namespace std;
typedef struct{
	int x,y;
}Point;
int movex[4]={0,1,0,-1};
int movey[4]={1,0,-1,0};
int main()
{
	int a,b,T,ex,ey,i;;
	scanf("%d",&T);
	while(T--)
	{
		int map[9][9]={{1,1,1,1,1,1,1,1,1},
		{1,0,0,1,0,0,1,0,1},
		{1,0,0,1,1,0,0,0,1},
        {1,0,1,0,1,1,0,1,1},
        {1,0,0,0,0,1,0,0,1},
        {1,1,0,1,0,1,0,0,1},
        {1,1,0,1,0,1,0,0,1},
        {1,1,0,1,0,0,0,0,1},
        {1,1,1,1,1,1,1,1,1}};
        int time[9][9]={{0}};
		scanf("%d%d%d%d",&a,&b,&ex,&ey);
		Point cur,next;
		queue<Point> Q;
		map[a][b]=1;
		time[a][b]=0;
		cur.x=a;cur.y=b;
		Q.push(cur);
		while(!Q.empty())
		{
			int x,y;
			cur=Q.front();
			Q.pop();
			if(cur.x==ex&&cur.y==ey)break;
			for(i=0;i<4;i++)
			{
				x=movex[i]+cur.x;
				y=movey[i]+cur.y;
				if(x>=0&&x<=8&&y>=0&&y<=8&&map[x][y]==0)
				{
					next.x=x;next.y=y;
					map[x][y]=1;
					time[x][y]=time[cur.x][cur.y]+1;
					Q.push(next);
				}
			}
		}
		printf("%d\n",time[ex][ey]);
	}
	return 0;
}


